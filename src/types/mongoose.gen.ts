/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from 'mongoose'

/**
 * Lean version of CommentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CommentDocument.toObject()`. To avoid conflicts with model names, use the type alias `CommentObject`.
 * ```
 * const commentObject = comment.toObject();
 * ```
 */
export type Comment = {
   content?: string
   user: User['_id'] | User
   post: Post['_id'] | Post
   postUser: User['_id'] | User
   createdAt?: Date
   likes: (User['_id'] | User)[]
   _id: mongoose.Types.ObjectId
}

/**
 * Lean version of CommentDocument (type alias of `Comment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Comment } from "../models"
 * import { CommentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const commentObject: CommentObject = comment.toObject();
 * ```
 */
export type CommentObject = Comment

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CommentQuery = mongoose.Query<any, CommentDocument, CommentQueries> & CommentQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `CommentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CommentQueries = {}

export type CommentMethods = {}

export type CommentStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Comment = mongoose.model<CommentDocument, CommentModel>("Comment", CommentSchema);
 * ```
 */
export type CommentModel = mongoose.Model<CommentDocument, CommentQueries> & CommentStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Comment schema instances:
 * ```
 * const CommentSchema: CommentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CommentSchema = mongoose.Schema<CommentDocument, CommentModel, CommentMethods, CommentQueries>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Comment = mongoose.model<CommentDocument, CommentModel>("Comment", CommentSchema);
 * ```
 */
export type CommentDocument = mongoose.Document<mongoose.Types.ObjectId, CommentQueries> &
   CommentMethods & {
      content?: string
      user: UserDocument['_id'] | UserDocument
      post: PostDocument['_id'] | PostDocument
      postUser: UserDocument['_id'] | UserDocument
      createdAt?: Date
      likes: mongoose.Types.Array<UserDocument['_id'] | UserDocument>
      _id: mongoose.Types.ObjectId
   }

/**
 * Lean version of NotificationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `NotificationDocument.toObject()`. To avoid conflicts with model names, use the type alias `NotificationObject`.
 * ```
 * const notificationObject = notification.toObject();
 * ```
 */
export type Notification = {
   type: 'like' | 'like-comment' | 'comment' | 'follow'
   sender: User['_id'] | User
   receiver: User['_id'] | User
   post?: Post['_id'] | Post
   comment?: Comment['_id'] | Comment
   createdAt?: Date
   isSeen?: boolean
   isRemoved?: boolean
   _id: mongoose.Types.ObjectId
}

/**
 * Lean version of NotificationDocument (type alias of `Notification`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Notification } from "../models"
 * import { NotificationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const notificationObject: NotificationObject = notification.toObject();
 * ```
 */
export type NotificationObject = Notification

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQuery = mongoose.Query<any, NotificationDocument, NotificationQueries> &
   NotificationQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `NotificationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type NotificationQueries = {}

export type NotificationMethods = {}

export type NotificationStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationModel = mongoose.Model<NotificationDocument, NotificationQueries> &
   NotificationStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Notification schema instances:
 * ```
 * const NotificationSchema: NotificationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type NotificationSchema = mongoose.Schema<
   NotificationDocument,
   NotificationModel,
   NotificationMethods,
   NotificationQueries
>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Notification = mongoose.model<NotificationDocument, NotificationModel>("Notification", NotificationSchema);
 * ```
 */
export type NotificationDocument = mongoose.Document<mongoose.Types.ObjectId, NotificationQueries> &
   NotificationMethods & {
      type: 'like' | 'like-comment' | 'comment' | 'follow'
      sender: UserDocument['_id'] | UserDocument
      receiver: UserDocument['_id'] | UserDocument
      post?: PostDocument['_id'] | PostDocument
      comment?: CommentDocument['_id'] | CommentDocument
      createdAt?: Date
      isSeen?: boolean
      isRemoved?: boolean
      _id: mongoose.Types.ObjectId
   }

/**
 * Lean version of PostDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `PostDocument.toObject()`. To avoid conflicts with model names, use the type alias `PostObject`.
 * ```
 * const postObject = post.toObject();
 * ```
 */
export type Post = {
   content?: string
   photo?: string
   user: User['_id'] | User
   createdAt?: Date
   likes: (User['_id'] | User)[]
   comments: (Comment['_id'] | Comment)[]
   isPublic?: boolean
   _id: mongoose.Types.ObjectId
}

/**
 * Lean version of PostDocument (type alias of `Post`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Post } from "../models"
 * import { PostObject } from "../interfaces/mongoose.gen.ts"
 *
 * const postObject: PostObject = post.toObject();
 * ```
 */
export type PostObject = Post

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type PostQuery = mongoose.Query<any, PostDocument, PostQueries> & PostQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `PostSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type PostQueries = {}

export type PostMethods = {}

export type PostStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Post = mongoose.model<PostDocument, PostModel>("Post", PostSchema);
 * ```
 */
export type PostModel = mongoose.Model<PostDocument, PostQueries> & PostStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new Post schema instances:
 * ```
 * const PostSchema: PostSchema = new mongoose.Schema({ ... })
 * ```
 */
export type PostSchema = mongoose.Schema<PostDocument, PostModel, PostMethods, PostQueries>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Post = mongoose.model<PostDocument, PostModel>("Post", PostSchema);
 * ```
 */
export type PostDocument = mongoose.Document<mongoose.Types.ObjectId, PostQueries> &
   PostMethods & {
      content?: string
      photo?: string
      user: UserDocument['_id'] | UserDocument
      createdAt?: Date
      likes: mongoose.Types.Array<UserDocument['_id'] | UserDocument>
      comments: mongoose.Types.Array<CommentDocument['_id'] | CommentDocument>
      isPublic?: boolean
      _id: mongoose.Types.ObjectId
   }

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
   name: string
   email: string
   password: string
   isGoogleUser?: boolean
   avatar?: string
   location?: string
   website?: string
   profession?: string
   cover?: string
   bio?: string
   dateOfBirth?: Date
   createdAt?: Date
   following: (User['_id'] | User)[]
   followers: (User['_id'] | User)[]
   totalNotifications?: number
   totalMessages?: number
   isVerified?: boolean
   posts: (Post['_id'] | Post)[]
   bookmarks: (Post['_id'] | Post)[]
   notifications: (Notification['_id'] | Notification)[]
   _id: mongoose.Types.ObjectId
}

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> & UserQueries

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {}

export type UserMethods = {
   comparePassword: (this: UserDocument, ...args: any[]) => any
   generateAuthToken: (this: UserDocument, ...args: any[]) => any
}

export type UserStatics = {}

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<UserDocument, UserModel, UserMethods, UserQueries>

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<mongoose.Types.ObjectId, UserQueries> &
   UserMethods & {
      name: string
      email: string
      password: string
      isGoogleUser?: boolean
      avatar?: string
      location?: string
      website?: string
      profession?: string
      cover?: string
      bio?: string
      dateOfBirth?: Date
      createdAt?: Date
      following: mongoose.Types.Array<UserDocument['_id'] | UserDocument>
      followers: mongoose.Types.Array<UserDocument['_id'] | UserDocument>
      totalNotifications?: number
      totalMessages?: number
      isVerified?: boolean
      posts: mongoose.Types.Array<PostDocument['_id'] | PostDocument>
      bookmarks: mongoose.Types.Array<PostDocument['_id'] | PostDocument>
      notifications: mongoose.Types.Array<NotificationDocument['_id'] | NotificationDocument>
      _id: mongoose.Types.ObjectId
   }

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
   return doc instanceof mongoose.Document
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
   [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
      ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
      : Exclude<Root[T], mongoose.Types.ObjectId>
}

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
   ? PopulatedProperty<DocType, T>
   : ParentProperty<T> extends keyof DocType
   ? Omit<DocType, ParentProperty<T>> & {
        [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<infer U>
           ? mongoose.Types.Array<
                ChildProperty<T> extends keyof U
                   ? PopulatedProperty<U, ChildProperty<T>>
                   : PopulatedDocument<U, ChildProperty<T>>
             >
           : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
           ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
           : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>
     }
   : DocType

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T
type Modify<T, R> = Omit<T, keyof R> & R

/**
 * Augment mongoose with Query.populate overloads
 */
declare module 'mongoose' {
   interface Query<ResultType, DocType, THelpers = {}> {
      populate<T extends string>(
         path: T,
         select?: string | any,
         model?: string | Model<any, THelpers>,
         match?: any
      ): Query<
         ResultType extends Array<DocType>
            ? Array<PopulatedDocument<Unarray<ResultType>, T>>
            : ResultType extends DocType
            ? PopulatedDocument<Unarray<ResultType>, T>
            : ResultType,
         DocType,
         THelpers
      > &
         THelpers

      populate<T extends string>(
         options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
      ): Query<
         ResultType extends Array<DocType>
            ? Array<PopulatedDocument<Unarray<ResultType>, T>>
            : ResultType extends DocType
            ? PopulatedDocument<Unarray<ResultType>, T>
            : ResultType,
         DocType,
         THelpers
      > &
         THelpers
   }
}
